---
title: "Lack of Resources and Rate Limiting"
slug: "lack-of-resources-and-rate-limiting"
hidden: true
createdAt: "2022-08-02T11:20:41.974Z"
updatedAt: "2022-08-05T20:39:20.528Z"
---
[block:html]
{
  "html": "<div>\n  <a href=\"/docs/vulnerability-guide\">< Back to tests</a>\n</div>"
}
[/block]

[block:html]
{
  "html": "<b>Severity</b>: <b><font color=\"#DB1E54\">High</font></b><br>\n<b>Test name</b>: Lack of Resources and Rate Limiting"
}
[/block]

[block:html]
{
  "html": "<table id=\"simple-table\">\n   <style>\n #simple-table {\n    border-collapse: separate;\n    width: 100%;\n    display: block;\n    display: table;\n  }\n#simple-table th {\n    padding: 1.5%;\n    text-align: left;\n    vertical-align: text-top;\n    background-color: #B2D6DA;\n  </style>\n  <body>\n    <tr>\n        <th><strong>Summary</strong></th>\n    </tr>\n</table>\n  </body>"
}
[/block]
API requests consume resources such as network, CPU, memory, and storage. The amount of resources required to satisfy a request greatly depends on the user input and endpoint business logic. Also, consider the fact that requests from multiple API clients compete for resources. An API is vulnerable if at least one of the following limits is missing or set inappropriately (e.g., too low/high):
* Execution timeouts
* Max allocable memory
* Number of file descriptors
* Number of processes
* Request payload size (e.g., uploads)
* Number of requests per client/resource
* Number of records per page to return in a single request response


[block:html]
{
  "html": "<table id=\"simple-table\">\n    <tr>\n        <th><strong>Example attack scenarios</strong></th>\n    </tr>\n</table>"
}
[/block]
**Scenario 1**: An attacker uploads a large image by issuing a POST request to `/api/v1/images`. When the upload is complete, the API creates multiple thumbnails with different sizes. Due to the size of the uploaded image, available memory is exhausted during the creation of thumbnails and the API becomes unresponsive.

**Scenario 2**: We have an application that contains the users list on a UI with a limit of `200` users per page. The users' list is retrieved from the server using the following query: `/api/users?page=1&size=200`. An attacker changes the `size` parameter to `200 000`, causing performance issues on the database. Meanwhile, the API becomes unresponsive and is unable to handle further requests from this or any other clients (aka DoS). The same scenario might be used to provoke Integer Overflow or Buffer Overflow errors.
[block:html]
{
  "html": "<table id=\"simple-table\">\n    <tr>\n        <th><strong>Remedy suggestions</strong></th>\n    </tr>\n</table>"
}
[/block]
  * Docker makes it easy to limit [memory](https://docs.docker.com/config/containers/resource_constraints/#memory), [CPU](https://docs.docker.com/config/containers/resource_constraints/#cpu), [number of restarts](https://docs.docker.com/engine/reference/commandline/run/#restart-policies---restart), [file descriptors, and processes](https://docs.docker.com/engine/reference/commandline/run/#set-ulimits-in-container---ulimit).
  * Implement a limit on how often a client can call the API within a defined timeframe.
  * Notify the client when the limit is exceeded by providing the limit number and the time at which the limit will be reset.
  * Add proper server-side validation for query string and request body parameters, specifically the one that controls the number of records to be returned in the response.
  * Define and enforce maximum size of data on all incoming parameters and payloads such as maximum length for strings and maximum number of elements in arrays.