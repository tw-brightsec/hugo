---
title: "Authorized Cross-Site Request Forgery (CSRF)"
slug: "authorized-cross-site-request-forgery-csrf"
hidden: true
createdAt: "2021-09-20T14:48:43.936Z"
updatedAt: "2022-03-31T09:29:10.320Z"
---
[block:html]
{
  "html": "<div>\n  <a href=\"/docs/vulnerability-guide\">< Back to tests</a>\n</div>"
}
[/block]

[block:html]
{
  "html": "<b>Severity</b>: <b><font color=\"#DE8800\">Medium</font></b><br>\n<b>Test name</b>: Cross-Site Request Forgery (CSRF)\n)\n"
}
[/block]

[block:html]
{
  "html": "<table id=\"simple-table\">\n   <style>\n #simple-table {\n    border-collapse: separate;\n    width: 100%;\n    display: block;\n    display: table;\n  }\n#simple-table th {\n    padding: 1.5%;\n    text-align: left;\n    vertical-align: text-top;\n    background-color: #B2D6DA;\n  </style>\n  <body>\n    <tr>\n        <th><strong>Summary</strong></th>\n    </tr>\n</table>\n  </body>"
}
[/block]
Authorized Cross-Site Request Forgery (CSRF) occurs when a malicious resource forces a user's web browser to perform an unwanted action on a trusted website when the user is authenticated. The attack works because the browser requests automatically include all cookies, including session cookies. If the user is authenticated to the site, the site cannot distinguish between legitimate requests and forged requests.

An attacker may deliver a dangerous URL to a user in different ways, for example:
* Send an email with a link to a malicious request.
* Send an email with a 0x0 fake image. The source of the image is a malicious request.
* Develop a fake web application with a prepared form. The form can send a malicious request automatically (`<body onload="document.forms[0].submit()">`) or by clicking a submit button.
* Develop a fake web application with a prepared JavaScript code that will send _"XMLHttpRequest"_.
[block:html]
{
  "html": "<table id=\"simple-table\">\n    <tr>\n        <th><strong>Impact</strong></th>\n    </tr>\n</table>\n"
}
[/block]
The CSRF attack may be executed for the following purposes:
* Send money from one account to another
* Change a user's password or a secret question
* Gain administrative privileges
* Make a purchase with the user's credentials
[block:html]
{
  "html": "<table id=\"simple-table\">\n    <tr>\n        <th><strong>Example</strong></th>\n    </tr>\n</table>"
}
[/block]
1. The user is using a bank website `(https://{your-bank}.com)` and has an active session in his browser (for example, this website is opened in one of the browser tabs).
2. An attacker creates a special link to transfer money between two accounts:

```
https://{your-bank}.com/transfer?from=account1&to=account2&amount=1000
```
3. The attacker sends this link to the user in any possible way. For example, the attacker can use an email to send the link that will be shown for the user as a â€œbroken" picture. The body of the email should contain:

```
<img src="https://{your-bank}.com/transfer?from=account1&to=account2&amount=1000/>
```
4. As soon as the user clicks this image, the corresponding URL opens in a new browser tab. As the user still has an active session (see point 1), the money from _"account1"_ will be transferred to _"account2"_. An unwanted action is performed on a trusted site when the user is authenticated.
[block:html]
{
  "html": "<table id=\"simple-table\">\n    <tr>\n        <th><strong>Location</strong></th>\n    </tr>\n</table>\n"
}
[/block]
* The issue can be found in the **source code** on the **server side**.
* The issue can be found in the **server configuration**.

[block:html]
{
  "html": "<table id=\"simple-table\">\n    <tr>\n        <th><strong>Remedy suggestions</strong></th>\n    </tr>\n</table>\n"
}
[/block]
* Check if your framework has built-in CSRF protection and use it.
* Always use the _"SameSite"_ Cookie Attribute for session cookies. Based on your application use cases, _"Lax"_ or _"Strict"_ value should be used.

```
Set-Cookie: JSESSIONID=xxxxx; SameSite=Strict
Set-Cookie: JSESSIONID=xxxxx; SameSite=Lax
```
* Do not use the GET method for state-changing requests. The GET request should be used only for retrieving the information.
* Try to avoid cross-site requests if possible. Modern web browsers support same-origin policy restriction, so do not configure CORS headers on your server.
* If your application supports cross-site requests, then carefully configure CORS headers. Configure allowed domain names in "_Access-Control-Allow-Origin_" header.
    * Nginx: 
    ```
    if ($http_origin ~* (whitelist\.address\.one|whitelist\.address\.two)$) {
    add_header Access-Control-Allow-Origin "$http_origin";
    }
    ```

    * Apache:
    ```
    <IfModule mod_headers.c>
        SetEnvIfNoCase Origin "https://(whitelist\.address\.one|whitelist\.address\.two)$" 
    AccessControlAllowOrigin=$0
        Header set Access-Control-Allow-Origin %{AccessControlAllowOrigin}e 
    env=AccessControlAllowOrigin
    </IfModule>
    ```
    * IIS 7.5+:
    ```
    <system.webServer>
    <httpProtocol>
        <customHeaders>
            <add name="Access-Control-Allow-Headers" value="Origin, X-Requested-With, Content-Type, Accept" />
            <add name="Access-Control-Allow-Methods" value="POST,GET,OPTIONS,PUT,DELETE" />
        </customHeaders>
    </httpProtocol>
            <rewrite>            
                <outboundRules>
                    <clear />                
                    <rule name="AddCrossDomainHeader">
                        <match serverVariable="RESPONSE_Access_Control_Allow_Origin" pattern=".*" />
                        <conditions logicalGrouping="MatchAll" trackAllCaptures="true">
                            <add input="{HTTP_ORIGIN}" pattern="(https://(whitelist\.address\.one|whitelist\.address\.two))" />
                        </conditions>
                        <action type="Rewrite" value="{C:0}" />
                    </rule>           
                </outboundRules>
            </rewrite>
    </system.webServer>
     ```

    * If the cookie is used for storing session information then the cookie have to be "_HTTP-only_" and "_Secured_" one:
    ```
    Set-Cookie: sessionId=some_session_hash; Expires=Thu, 21 Oct 2021 07:28:00 GMT; Secure; HttpOnly
    ```
[block:html]
{
  "html": "<table id=\"simple-table\">\n    <tr>\n        <th><strong>Classifications</strong></th>\n    </tr>\n</table>"
}
[/block]
* CWE-352
* CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N
[block:html]
{
  "html": "<table id=\"simple-table\">\n    <tr>\n        <th><strong>References</strong></th>\n    </tr>\n</table>"
}
[/block]
* [https://cwe.mitre.org/data/definitions/352.html](https://cwe.mitre.org/data/definitions/352.html)
* [https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF))
* [https://www.brightsec.com/blog/csrf-vs-xss/](https://www.brightsec.com/blog/csrf-vs-xss/)
* [https://www.brightsec.com/blog/cross-site-request-forgery-csrf/)](https://www.brightsec.com/blog/cross-site-request-forgery-csrf/s)
[block:html]
{
  "html": "<div>\n  <a href=\"/docs/vulnerability-guide\">< Back to tests</a>\n</div>"
}
[/block]